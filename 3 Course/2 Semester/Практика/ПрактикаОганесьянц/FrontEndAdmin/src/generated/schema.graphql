### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AggregateDentalDisease {
  _count: DentalDiseaseCountAggregateOutputType
  _max: DentalDiseaseMaxAggregateOutputType
  _min: DentalDiseaseMinAggregateOutputType
}

type AggregateDentalProcedure {
  _avg: DentalProcedureAvgAggregateOutputType
  _count: DentalProcedureCountAggregateOutputType
  _max: DentalProcedureMaxAggregateOutputType
  _min: DentalProcedureMinAggregateOutputType
  _sum: DentalProcedureSumAggregateOutputType
}

type AggregateMedicalRecord {
  _avg: MedicalRecordAvgAggregateOutputType
  _count: MedicalRecordCountAggregateOutputType
  _max: MedicalRecordMaxAggregateOutputType
  _min: MedicalRecordMinAggregateOutputType
  _sum: MedicalRecordSumAggregateOutputType
}

type AggregateUser {
  _avg: UserAvgAggregateOutputType
  _count: UserCountAggregateOutputType
  _max: UserMaxAggregateOutputType
  _min: UserMinAggregateOutputType
  _sum: UserSumAggregateOutputType
}

type BatchPayload {
  count: Int!
}

"""BigInt custom scalar type"""
scalar BigInt

"""Date custom scalar type"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

"""Decimal custom scalar type"""
scalar Decimal

type DentalDiseaseCountAggregateOutputType {
  _all: Int!
  id: Int!
  name: Int!
}

type DentalDiseaseCountOutputType {
  medicalRecords: Int!
}

input DentalDiseaseListRelationFilter {
  every: dentalDiseaseWhereInput
  none: dentalDiseaseWhereInput
  some: dentalDiseaseWhereInput
}

type DentalDiseaseMaxAggregateOutputType {
  id: String
  name: String
}

type DentalDiseaseMinAggregateOutputType {
  id: String
  name: String
}

enum DentalDiseaseScalarFieldEnum {
  id
  name
}

type DentalProcedureAvgAggregateOutputType {
  price: Float
}

type DentalProcedureCountAggregateOutputType {
  _all: Int!
  id: Int!
  name: Int!
  price: Int!
}

type DentalProcedureCountOutputType {
  medicalRecords: Int!
}

input DentalProcedureListRelationFilter {
  every: dentalProcedureWhereInput
  none: dentalProcedureWhereInput
  some: dentalProcedureWhereInput
}

type DentalProcedureMaxAggregateOutputType {
  id: String
  name: String
  price: Float
}

type DentalProcedureMinAggregateOutputType {
  id: String
  name: String
  price: Float
}

enum DentalProcedureScalarFieldEnum {
  id
  name
  price
}

type DentalProcedureSumAggregateOutputType {
  price: Float
}

type Enum {
  fields: [String!]!
  name: String!
}

input EnumuserRoleFieldUpdateOperationsInput {
  set: userRole
}

input EnumuserRoleFilter {
  equals: userRole
  in: [userRole]
  not: NestedEnumuserRoleFilter
  notIn: [userRole]
}

input EnumuserRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumuserRoleFilter
  _min: NestedEnumuserRoleFilter
  equals: userRole
  in: [userRole]
  not: NestedEnumuserRoleWithAggregatesFilter
  notIn: [userRole]
}

type Field {
  create: Boolean!
  editor: Boolean!
  filter: Boolean!
  id: String!
  isId: Boolean!
  kind: KindEnum!
  list: Boolean!
  name: String!
  order: Int!
  read: Boolean!
  relationField: Boolean
  required: Boolean!
  sort: Boolean!
  title: String!
  type: String!
  unique: Boolean!
  update: Boolean!
  upload: Boolean!
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

"""Json custom scalar type"""
scalar Json

enum KindEnum {
  enum
  object
  scalar
}

type MedicalRecordAvgAggregateOutputType {
  totalPrice: Float
}

type MedicalRecordCountAggregateOutputType {
  _all: Int!
  date: Int!
  dentistId: Int!
  id: Int!
  patientId: Int!
  totalPrice: Int!
}

type MedicalRecordCountOutputType {
  diseases: Int!
  procedures: Int!
}

input MedicalRecordListRelationFilter {
  every: medicalRecordWhereInput
  none: medicalRecordWhereInput
  some: medicalRecordWhereInput
}

type MedicalRecordMaxAggregateOutputType {
  date: DateTime
  dentistId: String
  id: String
  patientId: String
  totalPrice: Float
}

type MedicalRecordMinAggregateOutputType {
  date: DateTime
  dentistId: String
  id: String
  patientId: String
  totalPrice: Float
}

enum MedicalRecordScalarFieldEnum {
  date
  dentistId
  id
  patientId
  totalPrice
}

type MedicalRecordSumAggregateOutputType {
  totalPrice: Float
}

type Model {
  create: Boolean!
  delete: Boolean!
  displayFields: [String!]!
  fields: [Field!]!
  id: String!
  idField: String!
  name: String!
  update: Boolean!
}

type Mutation {
  createOneDentalDisease: dentalDisease!
  createOneDentalProcedure: dentalProcedure!
  createOneMedicalRecord: medicalRecord!
  createOneUser(data: UserCreateInput!): User!
  deleteManyDentalDisease: BatchPayload!
  deleteManyDentalProcedure: BatchPayload!
  deleteManyMedicalRecord: BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteOneDentalDisease: dentalDisease
  deleteOneDentalProcedure: dentalProcedure
  deleteOneMedicalRecord: medicalRecord
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateField(data: UpdateFieldInput!, id: String!, modelId: String!): Field!
  updateManyDentalDisease: BatchPayload!
  updateManyDentalProcedure: BatchPayload!
  updateManyMedicalRecord: BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateModel(data: UpdateModelInput!, id: String!): Model!
  updateOneDentalDisease: dentalDisease!
  updateOneDentalProcedure: dentalProcedure!
  updateOneMedicalRecord: medicalRecord!
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneDentalDisease: dentalDisease!
  upsertOneDentalProcedure: dentalProcedure!
  upsertOneMedicalRecord: medicalRecord!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime]
}

input NestedEnumuserRoleFilter {
  equals: userRole
  in: [userRole]
  not: NestedEnumuserRoleFilter
  notIn: [userRole]
}

input NestedEnumuserRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumuserRoleFilter
  _min: NestedEnumuserRoleFilter
  equals: userRole
  in: [userRole]
  not: NestedEnumuserRoleWithAggregatesFilter
  notIn: [userRole]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

type Query {
  aggregateDentalDisease: AggregateDentalDisease
  aggregateDentalProcedure: AggregateDentalProcedure
  aggregateMedicalRecord: AggregateMedicalRecord
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): AggregateUser
  findFirstDentalDisease: dentalDisease
  findFirstDentalProcedure: dentalProcedure
  findFirstMedicalRecord: medicalRecord
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): User
  findManyDentalDisease: [dentalDisease!]!
  findManyDentalDiseaseCount: Int!
  findManyDentalProcedure: [dentalProcedure!]!
  findManyDentalProcedureCount: Int!
  findManyMedicalRecord: [medicalRecord!]!
  findManyMedicalRecordCount: Int!
  findManyUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): [User!]!
  findManyUserCount(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum], orderBy: [UserOrderByWithRelationInput], skip: Int, take: Int, where: UserWhereInput): Int!
  findUniqueDentalDisease: dentalDisease
  findUniqueDentalProcedure: dentalProcedure
  findUniqueMedicalRecord: medicalRecord
  findUniqueUser(where: UserWhereUniqueInput!): User
  getSchema: Schema!
}

enum QueryMode {
  default
  insensitive
}

type Schema {
  enums: [Enum!]!
  models: [Model!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String]
  startsWith: String
}

input UpdateFieldInput {
  create: Boolean
  editor: Boolean
  filter: Boolean
  id: String
  isId: Boolean
  kind: KindEnum
  list: Boolean
  name: String
  order: Int
  read: Boolean
  relationField: Boolean
  required: Boolean
  sort: Boolean
  title: String
  type: String
  unique: Boolean
  update: Boolean
  upload: Boolean
}

input UpdateModelInput {
  create: Boolean
  delete: Boolean
  displayFields: [String]
  fields: [UpdateFieldInput]
  idField: String
  name: String
  update: Boolean
}

type User {
  _count: UserCountOutputType
  age: Int!
  firstName: String!
  id: String!
  lastName: String!
  login: String!
  medicalDentistRecord(cursor: medicalRecordWhereUniqueInput, distinct: MedicalRecordScalarFieldEnum, orderBy: medicalRecordOrderByWithRelationInput, skip: Int, take: Int, where: medicalRecordWhereInput): [medicalRecord!]!
  medicalPatientRecord(cursor: medicalRecordWhereUniqueInput, distinct: MedicalRecordScalarFieldEnum, orderBy: medicalRecordOrderByWithRelationInput, skip: Int, take: Int, where: medicalRecordWhereInput): [medicalRecord!]!
  password: String!
  role: userRole!
  tokenVersion: Int
}

type UserAvgAggregateOutputType {
  age: Float
  tokenVersion: Float
}

input UserAvgOrderByAggregateInput {
  age: SortOrder
  tokenVersion: SortOrder
}

type UserCountAggregateOutputType {
  _all: Int!
  age: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  login: Int!
  password: Int!
  role: Int!
  tokenVersion: Int!
}

input UserCountOrderByAggregateInput {
  age: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  login: SortOrder
  password: SortOrder
  role: SortOrder
  tokenVersion: SortOrder
}

type UserCountOutputType {
  medicalDentistRecord: Int!
  medicalPatientRecord: Int!
}

input UserCreateInput {
  age: Int!
  firstName: String!
  id: String
  lastName: String!
  login: String!
  medicalDentistRecord: medicalRecordCreateNestedManyWithoutDentistInput
  medicalPatientRecord: medicalRecordCreateNestedManyWithoutPatientInput
  password: String!
  role: userRole
  tokenVersion: Int
}

input UserCreateManyInput {
  age: Int!
  firstName: String!
  id: String
  lastName: String!
  login: String!
  password: String!
  role: userRole
  tokenVersion: Int
}

input UserCreateNestedOneWithoutMedicalDentistRecordInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutMedicalDentistRecordInput
  create: UserUncheckedCreateWithoutMedicalDentistRecordInput
}

input UserCreateNestedOneWithoutMedicalPatientRecordInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutMedicalPatientRecordInput
  create: UserUncheckedCreateWithoutMedicalPatientRecordInput
}

input UserCreateOrConnectWithoutMedicalDentistRecordInput {
  create: UserUncheckedCreateWithoutMedicalDentistRecordInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutMedicalPatientRecordInput {
  create: UserUncheckedCreateWithoutMedicalPatientRecordInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutMedicalDentistRecordInput {
  age: Int!
  firstName: String!
  id: String
  lastName: String!
  login: String!
  medicalPatientRecord: medicalRecordCreateNestedManyWithoutPatientInput
  password: String!
  role: userRole
  tokenVersion: Int
}

input UserCreateWithoutMedicalPatientRecordInput {
  age: Int!
  firstName: String!
  id: String
  lastName: String!
  login: String!
  medicalDentistRecord: medicalRecordCreateNestedManyWithoutDentistInput
  password: String!
  role: userRole
  tokenVersion: Int
}

type UserMaxAggregateOutputType {
  age: Int
  firstName: String
  id: String
  lastName: String
  login: String
  password: String
  role: userRole
  tokenVersion: Int
}

input UserMaxOrderByAggregateInput {
  age: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  login: SortOrder
  password: SortOrder
  role: SortOrder
  tokenVersion: SortOrder
}

type UserMinAggregateOutputType {
  age: Int
  firstName: String
  id: String
  lastName: String
  login: String
  password: String
  role: userRole
  tokenVersion: Int
}

input UserMinOrderByAggregateInput {
  age: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  login: SortOrder
  password: SortOrder
  role: SortOrder
  tokenVersion: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  age: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  login: SortOrder
  password: SortOrder
  role: SortOrder
  tokenVersion: SortOrder
}

input UserOrderByWithRelationInput {
  age: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  login: SortOrder
  medicalDentistRecord: medicalRecordOrderByRelationAggregateInput
  medicalPatientRecord: medicalRecordOrderByRelationAggregateInput
  password: SortOrder
  role: SortOrder
  tokenVersion: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  age
  firstName
  id
  lastName
  login
  password
  role
  tokenVersion
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput]
  NOT: [UserScalarWhereWithAggregatesInput]
  OR: [UserScalarWhereWithAggregatesInput]
  age: IntWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  login: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: EnumuserRoleWithAggregatesFilter
  tokenVersion: IntNullableWithAggregatesFilter
}

type UserSumAggregateOutputType {
  age: Int
  tokenVersion: Int
}

input UserSumOrderByAggregateInput {
  age: SortOrder
  tokenVersion: SortOrder
}

input UserUncheckedCreateInput {
  age: Int!
  firstName: String!
  id: String
  lastName: String!
  login: String!
  medicalDentistRecord: medicalRecordUncheckedCreateNestedManyWithoutDentistInput
  medicalPatientRecord: medicalRecordUncheckedCreateNestedManyWithoutPatientInput
  password: String!
  role: userRole
  tokenVersion: Int
}

input UserUncheckedCreateWithoutMedicalDentistRecordInput {
  age: Int!
  firstName: String!
  id: String
  lastName: String!
  login: String!
  medicalPatientRecord: medicalRecordUncheckedCreateNestedManyWithoutPatientInput
  password: String!
  role: userRole
  tokenVersion: Int
}

input UserUncheckedCreateWithoutMedicalPatientRecordInput {
  age: Int!
  firstName: String!
  id: String
  lastName: String!
  login: String!
  medicalDentistRecord: medicalRecordUncheckedCreateNestedManyWithoutDentistInput
  password: String!
  role: userRole
  tokenVersion: Int
}

input UserUncheckedUpdateInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  medicalDentistRecord: medicalRecordUncheckedUpdateManyWithoutDentistInput
  medicalPatientRecord: medicalRecordUncheckedUpdateManyWithoutPatientInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUncheckedUpdateManyInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutMedicalDentistRecordInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  medicalPatientRecord: medicalRecordUncheckedUpdateManyWithoutPatientInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUncheckedUpdateWithoutMedicalPatientRecordInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  medicalDentistRecord: medicalRecordUncheckedUpdateManyWithoutDentistInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUpdateInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  medicalDentistRecord: medicalRecordUpdateManyWithoutDentistInput
  medicalPatientRecord: medicalRecordUpdateManyWithoutPatientInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutMedicalDentistRecordInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutMedicalDentistRecordInput
  create: UserUncheckedCreateWithoutMedicalDentistRecordInput
  update: UserUncheckedUpdateWithoutMedicalDentistRecordInput
  upsert: UserUpsertWithoutMedicalDentistRecordInput
}

input UserUpdateOneRequiredWithoutMedicalPatientRecordInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutMedicalPatientRecordInput
  create: UserUncheckedCreateWithoutMedicalPatientRecordInput
  update: UserUncheckedUpdateWithoutMedicalPatientRecordInput
  upsert: UserUpsertWithoutMedicalPatientRecordInput
}

input UserUpdateWithoutMedicalDentistRecordInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  medicalPatientRecord: medicalRecordUpdateManyWithoutPatientInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUpdateWithoutMedicalPatientRecordInput {
  age: IntFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  login: StringFieldUpdateOperationsInput
  medicalDentistRecord: medicalRecordUpdateManyWithoutDentistInput
  password: StringFieldUpdateOperationsInput
  role: EnumuserRoleFieldUpdateOperationsInput
  tokenVersion: NullableIntFieldUpdateOperationsInput
}

input UserUpsertWithoutMedicalDentistRecordInput {
  create: UserUncheckedCreateWithoutMedicalDentistRecordInput!
  update: UserUncheckedUpdateWithoutMedicalDentistRecordInput!
}

input UserUpsertWithoutMedicalPatientRecordInput {
  create: UserUncheckedCreateWithoutMedicalPatientRecordInput!
  update: UserUncheckedUpdateWithoutMedicalPatientRecordInput!
}

input UserWhereInput {
  AND: [UserWhereInput]
  NOT: [UserWhereInput]
  OR: [UserWhereInput]
  age: IntFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  login: StringFilter
  medicalDentistRecord: MedicalRecordListRelationFilter
  medicalPatientRecord: MedicalRecordListRelationFilter
  password: StringFilter
  role: EnumuserRoleFilter
  tokenVersion: IntNullableFilter
}

input UserWhereUniqueInput {
  id: String
  login: String
}

type dentalDisease {
  _count: DentalDiseaseCountOutputType
  id: String!
  medicalRecords(cursor: medicalRecordWhereUniqueInput, distinct: MedicalRecordScalarFieldEnum, orderBy: medicalRecordOrderByWithRelationInput, skip: Int, take: Int, where: medicalRecordWhereInput): [medicalRecord!]!
  name: String!
}

input dentalDiseaseCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input dentalDiseaseCreateInput {
  id: String
  medicalRecords: medicalRecordCreateNestedManyWithoutDiseasesInput
  name: String!
}

input dentalDiseaseCreateManyInput {
  id: String
  name: String!
}

input dentalDiseaseCreateNestedManyWithoutMedicalRecordsInput {
  connect: [dentalDiseaseWhereUniqueInput]
  connectOrCreate: [dentalDiseaseCreateOrConnectWithoutMedicalRecordsInput]
  create: [dentalDiseaseCreateWithoutMedicalRecordsInput]
}

input dentalDiseaseCreateOrConnectWithoutMedicalRecordsInput {
  create: dentalDiseaseUncheckedCreateWithoutMedicalRecordsInput!
  where: dentalDiseaseWhereUniqueInput!
}

input dentalDiseaseCreateWithoutMedicalRecordsInput {
  id: String
  name: String!
}

input dentalDiseaseMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input dentalDiseaseMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input dentalDiseaseOrderByRelationAggregateInput {
  _count: SortOrder
}

input dentalDiseaseOrderByWithAggregationInput {
  _count: dentalDiseaseCountOrderByAggregateInput
  _max: dentalDiseaseMaxOrderByAggregateInput
  _min: dentalDiseaseMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input dentalDiseaseOrderByWithRelationInput {
  id: SortOrder
  medicalRecords: medicalRecordOrderByRelationAggregateInput
  name: SortOrder
}

input dentalDiseaseScalarWhereInput {
  AND: [dentalDiseaseScalarWhereInput]
  NOT: [dentalDiseaseScalarWhereInput]
  OR: [dentalDiseaseScalarWhereInput]
  id: StringFilter
  name: StringFilter
}

input dentalDiseaseScalarWhereWithAggregatesInput {
  AND: [dentalDiseaseScalarWhereWithAggregatesInput]
  NOT: [dentalDiseaseScalarWhereWithAggregatesInput]
  OR: [dentalDiseaseScalarWhereWithAggregatesInput]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input dentalDiseaseUncheckedCreateInput {
  id: String
  name: String!
}

input dentalDiseaseUncheckedCreateWithoutMedicalRecordsInput {
  id: String
  name: String!
}

input dentalDiseaseUncheckedUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input dentalDiseaseUncheckedUpdateManyInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input dentalDiseaseUncheckedUpdateManyWithoutDiseasesInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input dentalDiseaseUncheckedUpdateWithoutMedicalRecordsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input dentalDiseaseUpdateInput {
  id: StringFieldUpdateOperationsInput
  medicalRecords: medicalRecordUpdateManyWithoutDiseasesInput
  name: StringFieldUpdateOperationsInput
}

input dentalDiseaseUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input dentalDiseaseUpdateManyWithWhereWithoutMedicalRecordsInput {
  data: dentalDiseaseUncheckedUpdateManyWithoutDiseasesInput!
  where: dentalDiseaseScalarWhereInput!
}

input dentalDiseaseUpdateManyWithoutMedicalRecordsInput {
  connect: [dentalDiseaseWhereUniqueInput]
  connectOrCreate: [dentalDiseaseCreateOrConnectWithoutMedicalRecordsInput]
  create: [dentalDiseaseCreateWithoutMedicalRecordsInput]
  delete: [dentalDiseaseWhereUniqueInput]
  deleteMany: [dentalDiseaseScalarWhereInput]
  disconnect: [dentalDiseaseWhereUniqueInput]
  set: [dentalDiseaseWhereUniqueInput]
  update: [dentalDiseaseUpdateWithWhereUniqueWithoutMedicalRecordsInput]
  updateMany: [dentalDiseaseUpdateManyWithWhereWithoutMedicalRecordsInput]
  upsert: [dentalDiseaseUpsertWithWhereUniqueWithoutMedicalRecordsInput]
}

input dentalDiseaseUpdateWithWhereUniqueWithoutMedicalRecordsInput {
  data: dentalDiseaseUncheckedUpdateWithoutMedicalRecordsInput!
  where: dentalDiseaseWhereUniqueInput!
}

input dentalDiseaseUpdateWithoutMedicalRecordsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input dentalDiseaseUpsertWithWhereUniqueWithoutMedicalRecordsInput {
  create: dentalDiseaseUncheckedCreateWithoutMedicalRecordsInput!
  update: dentalDiseaseUncheckedUpdateWithoutMedicalRecordsInput!
  where: dentalDiseaseWhereUniqueInput!
}

input dentalDiseaseWhereInput {
  AND: [dentalDiseaseWhereInput]
  NOT: [dentalDiseaseWhereInput]
  OR: [dentalDiseaseWhereInput]
  id: StringFilter
  medicalRecords: MedicalRecordListRelationFilter
  name: StringFilter
}

input dentalDiseaseWhereUniqueInput {
  id: String
  name: String
}

type dentalProcedure {
  _count: DentalProcedureCountOutputType
  id: String!
  medicalRecords(cursor: medicalRecordWhereUniqueInput, distinct: MedicalRecordScalarFieldEnum, orderBy: medicalRecordOrderByWithRelationInput, skip: Int, take: Int, where: medicalRecordWhereInput): [medicalRecord!]!
  name: String!
  price: Float!
}

input dentalProcedureAvgOrderByAggregateInput {
  price: SortOrder
}

input dentalProcedureCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  price: SortOrder
}

input dentalProcedureCreateInput {
  id: String
  medicalRecords: medicalRecordCreateNestedManyWithoutProceduresInput
  name: String!
  price: Float!
}

input dentalProcedureCreateManyInput {
  id: String
  name: String!
  price: Float!
}

input dentalProcedureCreateNestedManyWithoutMedicalRecordsInput {
  connect: [dentalProcedureWhereUniqueInput]
  connectOrCreate: [dentalProcedureCreateOrConnectWithoutMedicalRecordsInput]
  create: [dentalProcedureCreateWithoutMedicalRecordsInput]
}

input dentalProcedureCreateOrConnectWithoutMedicalRecordsInput {
  create: dentalProcedureUncheckedCreateWithoutMedicalRecordsInput!
  where: dentalProcedureWhereUniqueInput!
}

input dentalProcedureCreateWithoutMedicalRecordsInput {
  id: String
  name: String!
  price: Float!
}

input dentalProcedureMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  price: SortOrder
}

input dentalProcedureMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  price: SortOrder
}

input dentalProcedureOrderByRelationAggregateInput {
  _count: SortOrder
}

input dentalProcedureOrderByWithAggregationInput {
  _avg: dentalProcedureAvgOrderByAggregateInput
  _count: dentalProcedureCountOrderByAggregateInput
  _max: dentalProcedureMaxOrderByAggregateInput
  _min: dentalProcedureMinOrderByAggregateInput
  _sum: dentalProcedureSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  price: SortOrder
}

input dentalProcedureOrderByWithRelationInput {
  id: SortOrder
  medicalRecords: medicalRecordOrderByRelationAggregateInput
  name: SortOrder
  price: SortOrder
}

input dentalProcedureScalarWhereInput {
  AND: [dentalProcedureScalarWhereInput]
  NOT: [dentalProcedureScalarWhereInput]
  OR: [dentalProcedureScalarWhereInput]
  id: StringFilter
  name: StringFilter
  price: FloatFilter
}

input dentalProcedureScalarWhereWithAggregatesInput {
  AND: [dentalProcedureScalarWhereWithAggregatesInput]
  NOT: [dentalProcedureScalarWhereWithAggregatesInput]
  OR: [dentalProcedureScalarWhereWithAggregatesInput]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  price: FloatWithAggregatesFilter
}

input dentalProcedureSumOrderByAggregateInput {
  price: SortOrder
}

input dentalProcedureUncheckedCreateInput {
  id: String
  name: String!
  price: Float!
}

input dentalProcedureUncheckedCreateWithoutMedicalRecordsInput {
  id: String
  name: String!
  price: Float!
}

input dentalProcedureUncheckedUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
}

input dentalProcedureUncheckedUpdateManyInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
}

input dentalProcedureUncheckedUpdateManyWithoutProceduresInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
}

input dentalProcedureUncheckedUpdateWithoutMedicalRecordsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
}

input dentalProcedureUpdateInput {
  id: StringFieldUpdateOperationsInput
  medicalRecords: medicalRecordUpdateManyWithoutProceduresInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
}

input dentalProcedureUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
}

input dentalProcedureUpdateManyWithWhereWithoutMedicalRecordsInput {
  data: dentalProcedureUncheckedUpdateManyWithoutProceduresInput!
  where: dentalProcedureScalarWhereInput!
}

input dentalProcedureUpdateManyWithoutMedicalRecordsInput {
  connect: [dentalProcedureWhereUniqueInput]
  connectOrCreate: [dentalProcedureCreateOrConnectWithoutMedicalRecordsInput]
  create: [dentalProcedureCreateWithoutMedicalRecordsInput]
  delete: [dentalProcedureWhereUniqueInput]
  deleteMany: [dentalProcedureScalarWhereInput]
  disconnect: [dentalProcedureWhereUniqueInput]
  set: [dentalProcedureWhereUniqueInput]
  update: [dentalProcedureUpdateWithWhereUniqueWithoutMedicalRecordsInput]
  updateMany: [dentalProcedureUpdateManyWithWhereWithoutMedicalRecordsInput]
  upsert: [dentalProcedureUpsertWithWhereUniqueWithoutMedicalRecordsInput]
}

input dentalProcedureUpdateWithWhereUniqueWithoutMedicalRecordsInput {
  data: dentalProcedureUncheckedUpdateWithoutMedicalRecordsInput!
  where: dentalProcedureWhereUniqueInput!
}

input dentalProcedureUpdateWithoutMedicalRecordsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
}

input dentalProcedureUpsertWithWhereUniqueWithoutMedicalRecordsInput {
  create: dentalProcedureUncheckedCreateWithoutMedicalRecordsInput!
  update: dentalProcedureUncheckedUpdateWithoutMedicalRecordsInput!
  where: dentalProcedureWhereUniqueInput!
}

input dentalProcedureWhereInput {
  AND: [dentalProcedureWhereInput]
  NOT: [dentalProcedureWhereInput]
  OR: [dentalProcedureWhereInput]
  id: StringFilter
  medicalRecords: MedicalRecordListRelationFilter
  name: StringFilter
  price: FloatFilter
}

input dentalProcedureWhereUniqueInput {
  id: String
  name: String
}

type medicalRecord {
  _count: MedicalRecordCountOutputType
  date: DateTime!
  dentist: User!
  dentistId: String!
  diseases(cursor: dentalDiseaseWhereUniqueInput, distinct: DentalDiseaseScalarFieldEnum, orderBy: dentalDiseaseOrderByWithRelationInput, skip: Int, take: Int, where: dentalDiseaseWhereInput): [dentalDisease!]!
  id: String!
  patient: User!
  patientId: String!
  procedures(cursor: dentalProcedureWhereUniqueInput, distinct: DentalProcedureScalarFieldEnum, orderBy: dentalProcedureOrderByWithRelationInput, skip: Int, take: Int, where: dentalProcedureWhereInput): [dentalProcedure!]!
  totalPrice: Float!
}

input medicalRecordAvgOrderByAggregateInput {
  totalPrice: SortOrder
}

input medicalRecordCountOrderByAggregateInput {
  date: SortOrder
  dentistId: SortOrder
  id: SortOrder
  patientId: SortOrder
  totalPrice: SortOrder
}

input medicalRecordCreateInput {
  date: DateTime!
  dentist: UserCreateNestedOneWithoutMedicalDentistRecordInput!
  diseases: dentalDiseaseCreateNestedManyWithoutMedicalRecordsInput
  id: String
  patient: UserCreateNestedOneWithoutMedicalPatientRecordInput!
  procedures: dentalProcedureCreateNestedManyWithoutMedicalRecordsInput
  totalPrice: Float!
}

input medicalRecordCreateManyDentistInput {
  date: DateTime!
  id: String
  patientId: String!
  totalPrice: Float!
}

input medicalRecordCreateManyDentistInputEnvelope {
  data: medicalRecordCreateManyDentistInput!
  skipDuplicates: Boolean
}

input medicalRecordCreateManyInput {
  date: DateTime!
  dentistId: String!
  id: String
  patientId: String!
  totalPrice: Float!
}

input medicalRecordCreateManyPatientInput {
  date: DateTime!
  dentistId: String!
  id: String
  totalPrice: Float!
}

input medicalRecordCreateManyPatientInputEnvelope {
  data: medicalRecordCreateManyPatientInput!
  skipDuplicates: Boolean
}

input medicalRecordCreateNestedManyWithoutDentistInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutDentistInput]
  create: [medicalRecordCreateWithoutDentistInput]
  createMany: medicalRecordCreateManyDentistInputEnvelope
}

input medicalRecordCreateNestedManyWithoutDiseasesInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutDiseasesInput]
  create: [medicalRecordCreateWithoutDiseasesInput]
}

input medicalRecordCreateNestedManyWithoutPatientInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutPatientInput]
  create: [medicalRecordCreateWithoutPatientInput]
  createMany: medicalRecordCreateManyPatientInputEnvelope
}

input medicalRecordCreateNestedManyWithoutProceduresInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutProceduresInput]
  create: [medicalRecordCreateWithoutProceduresInput]
}

input medicalRecordCreateOrConnectWithoutDentistInput {
  create: medicalRecordUncheckedCreateWithoutDentistInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordCreateOrConnectWithoutDiseasesInput {
  create: medicalRecordUncheckedCreateWithoutDiseasesInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordCreateOrConnectWithoutPatientInput {
  create: medicalRecordUncheckedCreateWithoutPatientInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordCreateOrConnectWithoutProceduresInput {
  create: medicalRecordUncheckedCreateWithoutProceduresInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordCreateWithoutDentistInput {
  date: DateTime!
  diseases: dentalDiseaseCreateNestedManyWithoutMedicalRecordsInput
  id: String
  patient: UserCreateNestedOneWithoutMedicalPatientRecordInput!
  procedures: dentalProcedureCreateNestedManyWithoutMedicalRecordsInput
  totalPrice: Float!
}

input medicalRecordCreateWithoutDiseasesInput {
  date: DateTime!
  dentist: UserCreateNestedOneWithoutMedicalDentistRecordInput!
  id: String
  patient: UserCreateNestedOneWithoutMedicalPatientRecordInput!
  procedures: dentalProcedureCreateNestedManyWithoutMedicalRecordsInput
  totalPrice: Float!
}

input medicalRecordCreateWithoutPatientInput {
  date: DateTime!
  dentist: UserCreateNestedOneWithoutMedicalDentistRecordInput!
  diseases: dentalDiseaseCreateNestedManyWithoutMedicalRecordsInput
  id: String
  procedures: dentalProcedureCreateNestedManyWithoutMedicalRecordsInput
  totalPrice: Float!
}

input medicalRecordCreateWithoutProceduresInput {
  date: DateTime!
  dentist: UserCreateNestedOneWithoutMedicalDentistRecordInput!
  diseases: dentalDiseaseCreateNestedManyWithoutMedicalRecordsInput
  id: String
  patient: UserCreateNestedOneWithoutMedicalPatientRecordInput!
  totalPrice: Float!
}

input medicalRecordMaxOrderByAggregateInput {
  date: SortOrder
  dentistId: SortOrder
  id: SortOrder
  patientId: SortOrder
  totalPrice: SortOrder
}

input medicalRecordMinOrderByAggregateInput {
  date: SortOrder
  dentistId: SortOrder
  id: SortOrder
  patientId: SortOrder
  totalPrice: SortOrder
}

input medicalRecordOrderByRelationAggregateInput {
  _count: SortOrder
}

input medicalRecordOrderByWithAggregationInput {
  _avg: medicalRecordAvgOrderByAggregateInput
  _count: medicalRecordCountOrderByAggregateInput
  _max: medicalRecordMaxOrderByAggregateInput
  _min: medicalRecordMinOrderByAggregateInput
  _sum: medicalRecordSumOrderByAggregateInput
  date: SortOrder
  dentistId: SortOrder
  id: SortOrder
  patientId: SortOrder
  totalPrice: SortOrder
}

input medicalRecordOrderByWithRelationInput {
  date: SortOrder
  dentist: UserOrderByWithRelationInput
  dentistId: SortOrder
  diseases: dentalDiseaseOrderByRelationAggregateInput
  id: SortOrder
  patient: UserOrderByWithRelationInput
  patientId: SortOrder
  procedures: dentalProcedureOrderByRelationAggregateInput
  totalPrice: SortOrder
}

input medicalRecordScalarWhereInput {
  AND: [medicalRecordScalarWhereInput]
  NOT: [medicalRecordScalarWhereInput]
  OR: [medicalRecordScalarWhereInput]
  date: DateTimeFilter
  dentistId: StringFilter
  id: StringFilter
  patientId: StringFilter
  totalPrice: FloatFilter
}

input medicalRecordScalarWhereWithAggregatesInput {
  AND: [medicalRecordScalarWhereWithAggregatesInput]
  NOT: [medicalRecordScalarWhereWithAggregatesInput]
  OR: [medicalRecordScalarWhereWithAggregatesInput]
  date: DateTimeWithAggregatesFilter
  dentistId: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  patientId: StringWithAggregatesFilter
  totalPrice: FloatWithAggregatesFilter
}

input medicalRecordSumOrderByAggregateInput {
  totalPrice: SortOrder
}

input medicalRecordUncheckedCreateInput {
  date: DateTime!
  dentistId: String!
  id: String
  patientId: String!
  totalPrice: Float!
}

input medicalRecordUncheckedCreateNestedManyWithoutDentistInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutDentistInput]
  create: [medicalRecordCreateWithoutDentistInput]
  createMany: medicalRecordCreateManyDentistInputEnvelope
}

input medicalRecordUncheckedCreateNestedManyWithoutPatientInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutPatientInput]
  create: [medicalRecordCreateWithoutPatientInput]
  createMany: medicalRecordCreateManyPatientInputEnvelope
}

input medicalRecordUncheckedCreateWithoutDentistInput {
  date: DateTime!
  id: String
  patientId: String!
  totalPrice: Float!
}

input medicalRecordUncheckedCreateWithoutDiseasesInput {
  date: DateTime!
  dentistId: String!
  id: String
  patientId: String!
  totalPrice: Float!
}

input medicalRecordUncheckedCreateWithoutPatientInput {
  date: DateTime!
  dentistId: String!
  id: String
  totalPrice: Float!
}

input medicalRecordUncheckedCreateWithoutProceduresInput {
  date: DateTime!
  dentistId: String!
  id: String
  patientId: String!
  totalPrice: Float!
}

input medicalRecordUncheckedUpdateInput {
  date: DateTimeFieldUpdateOperationsInput
  dentistId: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patientId: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateManyInput {
  date: DateTimeFieldUpdateOperationsInput
  dentistId: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patientId: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateManyWithoutDentistInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutDentistInput]
  create: [medicalRecordCreateWithoutDentistInput]
  createMany: medicalRecordCreateManyDentistInputEnvelope
  delete: [medicalRecordWhereUniqueInput]
  deleteMany: [medicalRecordScalarWhereInput]
  disconnect: [medicalRecordWhereUniqueInput]
  set: [medicalRecordWhereUniqueInput]
  update: [medicalRecordUpdateWithWhereUniqueWithoutDentistInput]
  updateMany: [medicalRecordUpdateManyWithWhereWithoutDentistInput]
  upsert: [medicalRecordUpsertWithWhereUniqueWithoutDentistInput]
}

input medicalRecordUncheckedUpdateManyWithoutMedicalDentistRecordInput {
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patientId: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateManyWithoutMedicalPatientRecordInput {
  date: DateTimeFieldUpdateOperationsInput
  dentistId: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateManyWithoutMedicalRecordsInput {
  date: DateTimeFieldUpdateOperationsInput
  dentistId: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patientId: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateManyWithoutPatientInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutPatientInput]
  create: [medicalRecordCreateWithoutPatientInput]
  createMany: medicalRecordCreateManyPatientInputEnvelope
  delete: [medicalRecordWhereUniqueInput]
  deleteMany: [medicalRecordScalarWhereInput]
  disconnect: [medicalRecordWhereUniqueInput]
  set: [medicalRecordWhereUniqueInput]
  update: [medicalRecordUpdateWithWhereUniqueWithoutPatientInput]
  updateMany: [medicalRecordUpdateManyWithWhereWithoutPatientInput]
  upsert: [medicalRecordUpsertWithWhereUniqueWithoutPatientInput]
}

input medicalRecordUncheckedUpdateWithoutDentistInput {
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patientId: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateWithoutDiseasesInput {
  date: DateTimeFieldUpdateOperationsInput
  dentistId: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patientId: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateWithoutPatientInput {
  date: DateTimeFieldUpdateOperationsInput
  dentistId: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUncheckedUpdateWithoutProceduresInput {
  date: DateTimeFieldUpdateOperationsInput
  dentistId: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  patientId: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUpdateInput {
  date: DateTimeFieldUpdateOperationsInput
  dentist: UserUpdateOneRequiredWithoutMedicalDentistRecordInput
  diseases: dentalDiseaseUpdateManyWithoutMedicalRecordsInput
  id: StringFieldUpdateOperationsInput
  patient: UserUpdateOneRequiredWithoutMedicalPatientRecordInput
  procedures: dentalProcedureUpdateManyWithoutMedicalRecordsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUpdateManyMutationInput {
  date: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUpdateManyWithWhereWithoutDentistInput {
  data: medicalRecordUncheckedUpdateManyWithoutMedicalDentistRecordInput!
  where: medicalRecordScalarWhereInput!
}

input medicalRecordUpdateManyWithWhereWithoutDiseasesInput {
  data: medicalRecordUncheckedUpdateManyWithoutMedicalRecordsInput!
  where: medicalRecordScalarWhereInput!
}

input medicalRecordUpdateManyWithWhereWithoutPatientInput {
  data: medicalRecordUncheckedUpdateManyWithoutMedicalPatientRecordInput!
  where: medicalRecordScalarWhereInput!
}

input medicalRecordUpdateManyWithWhereWithoutProceduresInput {
  data: medicalRecordUncheckedUpdateManyWithoutMedicalRecordsInput!
  where: medicalRecordScalarWhereInput!
}

input medicalRecordUpdateManyWithoutDentistInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutDentistInput]
  create: [medicalRecordCreateWithoutDentistInput]
  createMany: medicalRecordCreateManyDentistInputEnvelope
  delete: [medicalRecordWhereUniqueInput]
  deleteMany: [medicalRecordScalarWhereInput]
  disconnect: [medicalRecordWhereUniqueInput]
  set: [medicalRecordWhereUniqueInput]
  update: [medicalRecordUpdateWithWhereUniqueWithoutDentistInput]
  updateMany: [medicalRecordUpdateManyWithWhereWithoutDentistInput]
  upsert: [medicalRecordUpsertWithWhereUniqueWithoutDentistInput]
}

input medicalRecordUpdateManyWithoutDiseasesInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutDiseasesInput]
  create: [medicalRecordCreateWithoutDiseasesInput]
  delete: [medicalRecordWhereUniqueInput]
  deleteMany: [medicalRecordScalarWhereInput]
  disconnect: [medicalRecordWhereUniqueInput]
  set: [medicalRecordWhereUniqueInput]
  update: [medicalRecordUpdateWithWhereUniqueWithoutDiseasesInput]
  updateMany: [medicalRecordUpdateManyWithWhereWithoutDiseasesInput]
  upsert: [medicalRecordUpsertWithWhereUniqueWithoutDiseasesInput]
}

input medicalRecordUpdateManyWithoutPatientInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutPatientInput]
  create: [medicalRecordCreateWithoutPatientInput]
  createMany: medicalRecordCreateManyPatientInputEnvelope
  delete: [medicalRecordWhereUniqueInput]
  deleteMany: [medicalRecordScalarWhereInput]
  disconnect: [medicalRecordWhereUniqueInput]
  set: [medicalRecordWhereUniqueInput]
  update: [medicalRecordUpdateWithWhereUniqueWithoutPatientInput]
  updateMany: [medicalRecordUpdateManyWithWhereWithoutPatientInput]
  upsert: [medicalRecordUpsertWithWhereUniqueWithoutPatientInput]
}

input medicalRecordUpdateManyWithoutProceduresInput {
  connect: [medicalRecordWhereUniqueInput]
  connectOrCreate: [medicalRecordCreateOrConnectWithoutProceduresInput]
  create: [medicalRecordCreateWithoutProceduresInput]
  delete: [medicalRecordWhereUniqueInput]
  deleteMany: [medicalRecordScalarWhereInput]
  disconnect: [medicalRecordWhereUniqueInput]
  set: [medicalRecordWhereUniqueInput]
  update: [medicalRecordUpdateWithWhereUniqueWithoutProceduresInput]
  updateMany: [medicalRecordUpdateManyWithWhereWithoutProceduresInput]
  upsert: [medicalRecordUpsertWithWhereUniqueWithoutProceduresInput]
}

input medicalRecordUpdateWithWhereUniqueWithoutDentistInput {
  data: medicalRecordUncheckedUpdateWithoutDentistInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordUpdateWithWhereUniqueWithoutDiseasesInput {
  data: medicalRecordUncheckedUpdateWithoutDiseasesInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordUpdateWithWhereUniqueWithoutPatientInput {
  data: medicalRecordUncheckedUpdateWithoutPatientInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordUpdateWithWhereUniqueWithoutProceduresInput {
  data: medicalRecordUncheckedUpdateWithoutProceduresInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordUpdateWithoutDentistInput {
  date: DateTimeFieldUpdateOperationsInput
  diseases: dentalDiseaseUpdateManyWithoutMedicalRecordsInput
  id: StringFieldUpdateOperationsInput
  patient: UserUpdateOneRequiredWithoutMedicalPatientRecordInput
  procedures: dentalProcedureUpdateManyWithoutMedicalRecordsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUpdateWithoutDiseasesInput {
  date: DateTimeFieldUpdateOperationsInput
  dentist: UserUpdateOneRequiredWithoutMedicalDentistRecordInput
  id: StringFieldUpdateOperationsInput
  patient: UserUpdateOneRequiredWithoutMedicalPatientRecordInput
  procedures: dentalProcedureUpdateManyWithoutMedicalRecordsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUpdateWithoutPatientInput {
  date: DateTimeFieldUpdateOperationsInput
  dentist: UserUpdateOneRequiredWithoutMedicalDentistRecordInput
  diseases: dentalDiseaseUpdateManyWithoutMedicalRecordsInput
  id: StringFieldUpdateOperationsInput
  procedures: dentalProcedureUpdateManyWithoutMedicalRecordsInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUpdateWithoutProceduresInput {
  date: DateTimeFieldUpdateOperationsInput
  dentist: UserUpdateOneRequiredWithoutMedicalDentistRecordInput
  diseases: dentalDiseaseUpdateManyWithoutMedicalRecordsInput
  id: StringFieldUpdateOperationsInput
  patient: UserUpdateOneRequiredWithoutMedicalPatientRecordInput
  totalPrice: FloatFieldUpdateOperationsInput
}

input medicalRecordUpsertWithWhereUniqueWithoutDentistInput {
  create: medicalRecordUncheckedCreateWithoutDentistInput!
  update: medicalRecordUncheckedUpdateWithoutDentistInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordUpsertWithWhereUniqueWithoutDiseasesInput {
  create: medicalRecordUncheckedCreateWithoutDiseasesInput!
  update: medicalRecordUncheckedUpdateWithoutDiseasesInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordUpsertWithWhereUniqueWithoutPatientInput {
  create: medicalRecordUncheckedCreateWithoutPatientInput!
  update: medicalRecordUncheckedUpdateWithoutPatientInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordUpsertWithWhereUniqueWithoutProceduresInput {
  create: medicalRecordUncheckedCreateWithoutProceduresInput!
  update: medicalRecordUncheckedUpdateWithoutProceduresInput!
  where: medicalRecordWhereUniqueInput!
}

input medicalRecordWhereInput {
  AND: [medicalRecordWhereInput]
  NOT: [medicalRecordWhereInput]
  OR: [medicalRecordWhereInput]
  date: DateTimeFilter
  dentist: UserWhereInput
  dentistId: StringFilter
  diseases: DentalDiseaseListRelationFilter
  id: StringFilter
  patient: UserWhereInput
  patientId: StringFilter
  procedures: DentalProcedureListRelationFilter
  totalPrice: FloatFilter
}

input medicalRecordWhereUniqueInput {
  id: String
}

enum userRole {
  client
  dentist
}
